# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# PyInstaller
*.manifest
*.spec

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
# Users Admin Module

Ein wiederverwendbares Python-Modul für Benutzerverwaltung in FastAPI-Anwendungen.

## Überblick

Das `users_admin` Modul bietet eine vollständige, produktionsreife Lösung für:

- **Benutzerverwaltung**: CRUD-Operationen für Benutzerkonten
- **Passwort-Management**: Passwortänderung und -reset
- **Benutzerprofilverwaltung**: Benutzer können ihre eigenen Daten verwalten
- **Admin-Interface**: HTML-basierte Administrationsoberfläche
- **Flexible Architektur**: Basis-Klassen ermöglichen verschiedene Backend-Implementierungen

## Architektur

Das Modul folgt einer sauberen, schichtweisen Architektur mit abstrakten Basisklassen:

```
users_admin/
├── models/              # Pydantic-Modelle
│   └── admin_models.py  # Admin-Datenmodelle
├── services/            # Business Logic Layer
│   ├── base_user_admin_service.py    # Abstrakte Basis-Klasse
│   ├── user_admin_service.py         # SQLAlchemy-Implementierung
│   └── user_crud_service.py          # CRUD-Hilfsfunktionen
├── utils/               # Utility-Funktionen
│   ├── security_utils.py  # Passwort-Hashing
│   └── email_utils.py     # E-Mail-Versand
├── dependencies/        # FastAPI Dependencies
│   └── admin_deps.py    # Auth-Dependencies für Admin
├── routers/             # FastAPI Router
│   └── user_admin_router.py  # Admin-Endpunkte
├── templates/           # HTML-Templates
│   └── admin_users.html # Admin-Interface
├── config/              # Konfiguration
│   └── admin_config.py  # Modul-Konfiguration
└── examples/            # Integrations-Beispiele
```

## Features

### Flexible Service-Architektur

Das Modul verwendet abstrakte Basisklassen (`BaseUserAdminService`), die es ermöglichen, verschiedene Backend-Implementierungen zu nutzen:

- **SQLAlchemy** (Standard-Implementierung)
- **MongoDB** oder andere NoSQL-Datenbanken
- **LDAP** oder Active Directory
- **Externe APIs** oder Identity Provider (Keycloak, Auth0)

### Benutzermodell

- UUID-basierte Benutzer-IDs
- E-Mail als Benutzername
- Sichere Passwort-Speicherung (bcrypt)
- Benutzer-Status (aktiv/inaktiv)
- Rollen-System (normale Benutzer/Superuser)
- Zeitstempel für Erstellung, Updates und letzten Login

### Admin-Interface

- Moderne HTML-Oberfläche mit Bootstrap 5
- Benutzer auflisten, erstellen, bearbeiten und löschen
- Modal-Dialoge für Benutzeroperationen
- Responsive Design für mobile Geräte

### API-Endpunkte

#### Admin-Interface
- `GET /api/admin` - Admin-Seite (HTML)

#### Benutzerverwaltung (`/api/users`)
- `GET /api/users` - Benutzer auflisten (Admin)
- `POST /api/users` - Benutzer erstellen (Admin)
- `POST /api/users/signup` - Öffentliche Registrierung
- `GET /api/users/me` - Eigene Informationen
- `PATCH /api/users/me` - Eigene Daten aktualisieren
- `PATCH /api/users/me/password` - Eigenes Passwort ändern
- `DELETE /api/users/me` - Eigenes Konto löschen
- `GET /api/users/{id}` - Benutzer nach ID
- `PATCH /api/users/{id}` - Benutzer aktualisieren (Admin)
- `DELETE /api/users/{id}` - Benutzer löschen (Admin)

## Installation & Integration

### 1. Installation

```bash
cd backend/users_admin
pip install -e .
```

### 2. Einfache Integration

```python
from fastapi import FastAPI
from sqlalchemy.orm import Session
from users_admin import UserAdminRouter
from users_admin.services import UserAdminService
from users_admin.utils import SecurityUtils
from users_admin.config import AdminConfig

app = FastAPI()

# Konfiguration
config = AdminConfig(
    templates_dir="backend/users_admin/templates",
    api_prefix="/api",
    emails_enabled=True,
    smtp_host="smtp.example.com",
    smtp_port=587
)

# Security Utils
security_utils = SecurityUtils()

# Dependencies
from backend.database.base import get_db
from backend.api.deps import get_current_user, get_current_active_superuser

# Router erstellen
admin_router = UserAdminRouter(
    database_session=get_db,
    config=config,
    user_model=User,  # Ihr SQLAlchemy User Model
    security_utils=security_utils,
    get_current_user=get_current_user,
    get_current_superuser=get_current_active_superuser,
    superuser_or_redirect=superuser_or_redirect
)

# Router in App einbinden
app.include_router(admin_router.router)
```

### 3. Eigene Service-Implementierung

Sie können eigene Service-Implementierungen erstellen, z.B. für LDAP:

```python
from users_admin.services import BaseUserAdminService

class LDAPUserAdminService(BaseUserAdminService):
    """LDAP-basierte Benutzerverwaltung."""

    def __init__(self, ldap_connection):
        self.ldap = ldap_connection

    def get_user_by_email(self, email: str):
        # LDAP-Implementierung
        return self.ldap.search(f"mail={email}")

    def create_user(self, user_data):
        # LDAP-Implementierung
        return self.ldap.add_user(user_data)

    # ... weitere Methoden
```

### 4. Multi-Provider-Setup mit Fallback

Sie können mehrere Service-Provider kombinieren:

```python
from users_admin.services import BaseUserAdminService

class MultiProviderUserService(BaseUserAdminService):
    """Service mit mehreren Backends und Fallback."""

    def __init__(self, primary_service, fallback_service):
        self.primary = primary_service
        self.fallback = fallback_service

    def get_user_by_email(self, email: str):
        # Zuerst primären Service versuchen
        user = self.primary.get_user_by_email(email)

        # Falls nicht gefunden, Fallback verwenden
        if not user:
            user = self.fallback.get_user_by_email(email)

        return user

    # ... weitere Methoden mit Fallback-Logik
```

## Konfiguration

### AdminConfig

```python
config = AdminConfig(
    # Template-Verzeichnis
    templates_dir="backend/users_admin/templates",

    # API-Präfix
    api_prefix="/api",

    # Router-Tags
    router_tags=["users", "admin"],

    # E-Mail-Einstellungen
    emails_enabled=True,
    smtp_host="smtp.example.com",
    smtp_port=587,
    smtp_user="user@example.com",
    smtp_password="password",
    emails_from_email="noreply@example.com",
    emails_from_name="My App",

    # Passwort-Reset-Token Gültigkeit
    password_reset_token_expire_minutes=60,

    # Logging
    enable_logging=True,
    log_file="logs/users_admin.log"
)
```

## Anpassung

### Eigene Templates

Sie können die HTML-Templates anpassen, indem Sie das Template-Verzeichnis in der Konfiguration angeben:

```python
config = AdminConfig(
    templates_dir="my_custom_templates"
)
```

### Eigene Dependencies

Sie können eigene Dependencies für Authentifizierung und Autorisierung bereitstellen:

```python
from fastapi import Depends, HTTPException

def my_custom_auth(token: str = Depends(oauth2_scheme)):
    # Ihre eigene Auth-Logik
    return verify_token(token)

admin_router = UserAdminRouter(
    database_session=get_db,
    config=config,
    get_current_user=my_custom_auth,
    # ...
)
```

## Sicherheit

- **Passwort-Hashing**: Verwendet bcrypt für sicheres Passwort-Hashing
- **Token-basierte Authentifizierung**: Kompatibel mit JWT und OAuth2
- **Rollentrennung**: Unterscheidung zwischen normalen Benutzern und Admins
- **Input-Validierung**: Pydantic-Modelle validieren alle Eingaben
- **CSRF-Schutz**: Empfohlen für Produktionsumgebungen

## Abhängigkeiten

- FastAPI >= 0.100.0
- SQLAlchemy >= 2.0 (für Standard-Implementierung)
- Pydantic >= 2.7
- passlib (für Passwort-Hashing)
- bcrypt >= 4.0.0
- python-multipart >= 0.0.5
- jinja2 >= 3.1.0

## Lizenz

[Ihre Lizenz hier]

## Autor

Fabian Aichele <aichele@zykl.io>

## Changelog

### Version 1.0.0 (2025-10-10)

- Initiales Release
- Basis-Service-Architektur mit abstrakten Klassen
- SQLAlchemy-Implementierung
- HTML-Admin-Interface
- CRUD-Operationen für Benutzer
- Passwort-Management
- E-Mail-Utilities
- Konfigurierbare Dependencies

